## 1. 进程
1. 创建11个进程。输入进程id，相应的进程会被杀死
2. 没有杀死进程
3. proc_number 在个进程中的值是相同的，进程没有对proc_number 进行写操作
5. 内部使用kill函数，外部使用kill命令更好

## 2. 线程实验
实验结果：

0 0 7363 7510/7363
249676319 0 315045573 278465154/564721892
1436296914 0 1770825363 1587484917/3207122277
2041889266 0 2468978953 2239199491/4510868174
2212430751 0 2667746389 2424544582/4880177138
2274636879 0 2739423935 2492058711/5014060814
2315770782 0 2802615978 2546318162/5118386728
2369189234 0 2863438640 2602674310/5232627874
2427223212 0 2930120344 2665226694/5357343556
2489144680 0 3001396191 2731946464/5490540871
2543833129 0 3073671284 2796167618/5617504364
3035781337 0 3664640019 3337532808/6700421335q

CPU占用率：
进�� USER      PR  NI    VIRT    RES    SHR �  %CPU %MEM     TIME+ COMMAND     
23211 huloves   20   0   31280    876    796 S 299.3  0.0   0:52.90 a.out 

%CPU：299.3

1. 前三列数不相等，都有可能
2. 	原因：三个线程是并发的。三个线程对全局变量访问的时间不一样，比如在第一个线程将全局变量加到100时，第二个线程将全局变量加到了1000，第三个简称加到了999。**数字在进行操作的时候会从储存变量的寄存器中取出拷贝到CPU的运算器中，在CPU中进行++操作后在放回到变量的寄存器中。**第一个进程将变量从寄存器中拷贝到CPU中后还没有存储在寄存器中，就被其他的线程把CPU的使用权抢了过去。其他的线程将运算后的数据存入寄存器后，比如线程3将999存入寄存器，此时变量为999，线程1抢到CPU的使用权，将运算的数据存入CPU，就会覆盖掉之前的数据，变量的值变为100
3. 主线程结束，子线程跟着结束。不好，数据没有得到保护

## 互斥实验
运行结果：
huloves@huloves:~/vacation_study/shi_yan$ ./a.out 
Thread1: 0
Thread1: 1
Thread1: 2
Thread1: 3
Thread1: 4
Thread1: 5
Thread1: 6
Thread1: 7
Thread1: 8
Thread1: 9
Thread1: 10
^C
<br/>

huloves@huloves:~/vacation_study/shi_yan$ ./a.out  
Thread1: 0
Thread1: 1
Thread1: 2
Thread1: 3
Thread1: 4
Thread2: 0
Thread2: 1
Thread2: 2
Thread2: 3
Thread2: 4
Thread2: 5
Thread2: 6
Thread2: 7
^C
<br/>

huloves@huloves:~/vacation_study/shi_yan$ ./a.out 
Thread1: 0
Thread1: 1
Thread1: 2
Thread1: 3
Thread1: 4
^C
<br />

huloves@huloves:~/vacation_study/shi_yan$ 

1. 可能会死锁
2. 真的死锁了，运行的结果不一样，但都发生了死锁。
原因（不确定）：pthread_mutex_t 是 typedef 来的，相当与mutex也是一个全局变量，mutex的初始值为1，然后发生了实验二的问题，当线程1的mutex1=0时，对mutex1进行上锁mutex1++后，mutex1=1，然后CPU的使用权被线程2抢夺到，线程2 执行到pthread_mutex_lock,对mutex1进行上锁++操作。然后到线程1，就死锁了。mutex2同理。